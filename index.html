<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>♟️ Chess</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #1a1a2e;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: system-ui;
            padding: 10px;
        }
        
        /* Screens */
        .screen { display: none; flex-direction: column; align-items: center; }
        .screen.active { display: flex; }
        
        h1 { color: white; margin-bottom: 1rem; }
        
        /* Menu */
        .menu-btn {
            padding: 1rem 2rem;
            margin: 0.5rem;
            font-size: 1.2rem;
            background: #333;
            color: white;
            border: 2px solid #555;
            border-radius: 10px;
            cursor: pointer;
            width: 200px;
        }
        .menu-btn:hover { background: #444; }
        
        /* Board */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 45px);
            grid-template-rows: repeat(8, 45px);
            border: 5px solid #4a3728;
            user-select: none;
        }
        .square {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        .white-sq { background: #f0d9b5; }
        .black-sq { background: #b58863; }
        .selected { box-shadow: inset 0 0 0 3px #ffff00; }
        .possible { position: relative; }
        .possible::after {
            content: ''; position: absolute;
            width: 12px; height: 12px;
            background: rgba(0,180,0,0.5);
            border-radius: 50%;
        }
        .capture::after {
            width: 40px; height: 40px;
            background: none;
            border: 4px solid rgba(0,180,0,0.5);
            border-radius: 50%;
        }
        
        .piece {
            font-size: 35px;
            line-height: 1;
        }
        
        #status {
            color: #ccc;
            margin: 10px;
            font-size: 1rem;
            text-align: center;
        }
        
        .back-btn {
            padding: 0.5rem 1rem;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        @media (max-width: 400px) {
            #board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            .square { width: 40px; height: 40px; }
            .piece { font-size: 30px; }
        }
    </style>
</head>
<body>
    <!-- Menu Screen -->
    <div id="menu-screen" class="screen active">
        <h1>♟️ Chess</h1>
        <button class="menu-btn" onclick="showScreen('pvp-screen')">vs Player</button>
        <button class="menu-btn" onclick="showScreen('pvc-screen')">vs Computer</button>
    </div>
    
    <!-- PvP Screen -->
    <div id="pvp-screen" class="screen">
        <h1>vs Player</h1>
        <div id="status">White's turn</div>
        <div id="board"></div>
        <button class="back-btn" onclick="showScreen('menu-screen')">Back to Menu</button>
    </div>
    
    <!-- PvC Screen -->
    <div id="pvc-screen" class="screen">
        <h1>vs Computer</h1>
        <div id="status-c">White's turn</div>
        <div id="board-c"></div>
        <button class="back-btn" onclick="showScreen('menu-screen')">Back to Menu</button>
    </div>

    <script>
        const pieces = {
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔',
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚'
        };
        
        const initialBoard = [
            ['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R']
        ];
        
        let board = [], turn = 'white', selected = null, possibleMoves = [];
        let mode = 'pvp';
        
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if (id === 'pvp-screen') { mode = 'pvp'; initGame('board'); }
            if (id === 'pvc-screen') { mode = 'pvc'; initGame('board-c'); }
        }
        
        function initGame(boardId) {
            board = initialBoard.map(row => [...row]);
            turn = 'white';
            selected = null;
            possibleMoves = [];
            render(boardId);
        }
        
        function render(boardId) {
            const boardEl = document.getElementById(boardId);
            if (!boardEl) return;
            boardEl.innerHTML = '';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `square ${(r + c) % 2 === 0 ? 'white-sq' : 'black-sq'}`;
                    sq.onclick = () => handleClick(r, c, boardId);
                    
                    const piece = board[r][c];
                    if (piece) {
                        const p = document.createElement('span');
                        p.className = 'piece';
                        p.textContent = pieces[piece];
                        // White pieces = black text, Black pieces = black text on light, white on dark
                        if (piece === piece.toUpperCase()) {
                            p.style.color = '#fff';
                            p.style.textShadow = '0 0 2px #000';
                        } else {
                            const isDark = (r + c) % 2 === 1;
                            p.style.color = isDark ? '#fff' : '#000';
                            p.style.textShadow = isDark ? '0 0 2px #000' : 'none';
                        }
                        sq.appendChild(p);
                    }
                    
                    if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');
                    if (possibleMoves.some(m => m.r === r && m.c === c)) {
                        sq.classList.add('possible');
                        if (board[r][c]) sq.classList.add('capture');
                    }
                    
                    boardEl.appendChild(sq);
                }
            }
            
            const statusId = mode === 'pvp' ? 'status' : 'status-c';
            const statusEl = document.getElementById(statusId);
            if (statusEl) statusEl.textContent = turn === 'white' ? "White's turn" : "Black's turn";
        }
        
        function handleClick(r, c, boardId) {
            if (mode === 'pvc' && turn === 'black') return;
            
            const piece = board[r][c];
            const isMyPiece = piece && (turn === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase());
            
            if (isMyPiece) {
                selected = {r, c};
                possibleMoves = getValidMoves(r, c, piece);
                render(boardId);
            } else if (selected && possibleMoves.some(m => m.r === r && m.c === c)) {
                movePiece(selected.r, selected.c, r, c, boardId);
            }
        }
        
        function movePiece(fromR, fromC, toR, toC, boardId) {
            board[toR][toC] = board[fromR][fromC];
            board[fromR][fromC] = '';
            
            // Pawn promotion
            if (board[toR][toC] === 'P' && toR === 0) board[toR][toC] = 'Q';
            if (board[toR][toC] === 'p' && toR === 7) board[toR][toC] = 'q';
            
            selected = null;
            possibleMoves = [];
            turn = turn === 'white' ? 'black' : 'white';
            render(boardId);
            
            if (mode === 'pvc' && turn === 'black') {
                setTimeout(() => computerMove('board-c'), 500);
            }
        }
        
        function computerMove(boardId) {
            const allMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece === piece.toLowerCase()) {
                        const moves = getValidMoves(r, c, piece);
                        moves.forEach(m => allMoves.push({from: {r, c}, to: m}));
                    }
                }
            }
            
            if (allMoves.length > 0) {
                const move = allMoves[Math.floor(Math.random() * allMoves.length)];
                movePiece(move.from.r, move.from.c, move.to.r, move.to.c, boardId);
            }
        }
        
        function getValidMoves(r, c, piece) {
            const moves = [];
            const isWhite = piece === piece.toUpperCase();
            const direction = isWhite ? -1 : 1;
            
            const addIfValid = (r, c) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const target = board[r][c];
                    if (!target || (isWhite ? target === target.toLowerCase() : target === target.toUpperCase())) {
                        moves.push({r, c});
                        return !target;
                    }
                }
                return false;
            };
            
            switch(piece.toLowerCase()) {
                case 'p':
                    // Forward 1
                    if (board[r + direction]?.[c] === '') {
                        addIfValid(r + direction, c);
                        // Forward 2 (start)
                        if ((isWhite && r === 6) || (!isWhite && r === 1)) {
                            if (board[r + 2 * direction]?.[c] === '') {
                                addIfValid(r + 2 * direction, c);
                            }
                        }
                    }
                    // Capture diagonal
                    addIfValid(r + direction, c - 1);
                    addIfValid(r + direction, c + 1);
                    break;
                case 'r':
                    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            if (!addIfValid(r + dr*i, c + dc*i)) break;
                        }
                    });
                    break;
                case 'b':
                    [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            if (!addIfValid(r + dr*i, c + dc*i)) break;
                        }
                    });
                    break;
                case 'q':
                    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            if (!addIfValid(r + dr*i, c + dc*i)) break;
                        }
                    });
                    break;
                case 'n':
                    [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr, dc]) => {
                        addIfValid(r + dr, c + dc);
                    });
                    break;
                case 'k':
                    [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        addIfValid(r + dr, c + dc);
                    });
                    break;
            }
            return moves;
        }
    </script>
</body>
</html>
